// =============================================================================
// Конфигурация генератора Prisma Client
// =============================================================================

/// Генератор создаёт TypeScript-клиент (`@prisma/client`) на основе этой схемы.
/// Запускается командой: `npx prisma generate`
generator client {
  provider = "prisma-client-js"
}

// =============================================================================
// Источник данных (PostgreSQL)
// =============================================================================

/// Подключение к базе данных PostgreSQL.
/// URL хранится в переменной окружения DATABASE_URL (файл .env.local).
/// Формат: postgresql://USER:PASSWORD@HOST:PORT/DATABASE
datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// =============================================================================
// МОДЕЛИ AUTH.JS
// Эти модели требуются библиотекой Auth.js (NextAuth v5) и управляются
// автоматически через PrismaAdapter. Не удалять и не переименовывать поля!
// =============================================================================

/// Пользователь приложения.
/// Создаётся Auth.js автоматически при первом входе через Google.
/// Мы расширили модель двумя полями для бизнес-логики (`myLists`, `sharedLists`).
model User {
  id            String          @id @default(cuid())
  name          String?
  email         String          @unique
  emailVerified DateTime?
  image         String?

  /// Связанные OAuth-аккаунты пользователя (например, Google).
  accounts      Account[]

  /// Активные сессии пользователя.
  sessions      Session[]

  // -------------------------------------------------------------------------
  // Наши бизнес-поля (добавлены поверх базовой схемы Auth.js)
  // -------------------------------------------------------------------------

  /// Списки, созданные этим пользователем (он — владелец).
  myLists       List[]  @relation("Owner")

  /// Списки, к которым пользователь имеет доступ по приглашению.
  sharedLists   List[]  @relation("Shared")

  /// Записи, добавленные этим пользователем.
  addedItems    Item[]          @relation("AddedItems")

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

/// OAuth-аккаунт, привязанный к пользователю.
/// Хранит токены доступа от провайдера (Google и т.д.).
/// Составной первичный ключ: provider + providerAccountId.
model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
 
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
 
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
 
  @@id([provider, providerAccountId])
}

/// Сессия пользователя, управляемая Auth.js.
/// Хранит токен сессии в cookie. Автоматически удаляется по истечении `expires`.
model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
 
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/// Токен для верификации email (используется при passwordless-входе).
/// В текущей реализации не применяется (вход только через Google).
model VerificationToken {
  identifier String
  token      String
  expires    DateTime
 
  @@id([identifier, token])
}

// =============================================================================
// БИЗНЕС-МОДЕЛИ ПРИЛОЖЕНИЯ
// =============================================================================

/// Список.
/// Может принадлежать одному владельцу и быть общим для нескольких пользователей.
model List {
  id        String   @id @default(cuid())
  title     String

  /// Цвет иконки списка (зарезервировано для будущей функциональности).
  color     String   @default("blue")
  
  // ---- Связь "Владелец" (Many-to-One) ----

  /// ID пользователя-владельца. Используется для проверки прав в Server Actions.
  ownerId   String

  /// Объект владельца. Каскадное удаление: при удалении пользователя его списки тоже удаляются.
  owner     User     @relation("Owner", fields: [ownerId], references: [id], onDelete: Cascade)

  // ---- Связь "Записи" (One-to-Many) ----

  /// Записи, входящие в этот список.
  items     Item[]

  // ---- Связь "Общий доступ" (Many-to-Many) ----

  /// Пользователи, которые имеют доступ к списку по приглашению (не владельцы).
  /// Prisma автоматически создаёт таблицу-связку для этого отношения.
  sharedWith User[] @relation("Shared")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Сохраняем имя таблицы в БД без изменений (миграция не требуется).
  @@map("ShoppingList")
}

/// Запись внутри списка.
model Item {
  id          String       @id @default(cuid())

  /// Название записи (например, "Молоко 1л").
  name        String

  /// Статус покупки: false — не куплен, true — куплен (зачёркнут в UI).
  isCompleted Boolean      @default(false)
  
  // ---- Связь с List (Many-to-One) ----

  /// ID списка, которому принадлежит запись.
  listId      String

  /// Родительский список. Каскадное удаление: при удалении списка все его записи тоже удаляются.
  list        List @relation(fields: [listId], references: [id], onDelete: Cascade)

  // ---- Кто добавил запись ----

  /// ID пользователя, добавившего запись (опционально: NULL для старых записей).
  addedById   String?

  /// Пользователь, добавивший запись. При удалении пользователя поле обнуляется.
  addedBy     User?        @relation("AddedItems", fields: [addedById], references: [id], onDelete: SetNull)

  createdAt   DateTime     @default(now())
}